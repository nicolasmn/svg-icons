const fs = require('fs')
const merge = require('lodash.merge')
const svgTools = require('simple-svg-tools')
const HTMLParser = require('fast-html-parser')


class GenerateIcons {
	static get defaults() {
		return {
			src: '.',              // Source folder where the icons are
			watch: false,          // Watch `src` folder for changes
			svg: '',               // Filepath of the generated SVG sprite
			pretty: false,         // Pretty print output file
			scss: '',              // Write file to disk, `false` or filepath
			sass: '',              // Write file to disk, `false` or filepath
			stylus: '',            // Write file to disk, `false` or filepath
			variable: 'svg-icons', // Name of the variable with generated map
			indent: '\t',          // Either `tab` or `space`
		}
	}

	constructor(options) {
		this.options = merge({}, this.constructor.defaults, options)
		this.load()
	}

	/**
	 * Loads all SVG files from `options.src` dir
	 * @returns {void}
	 */
	load() {
		this.icons = new Promise((resolve, reject) => {
			try {
				svgTools.ImportDir(this.options.src).then(collection => {
					if (this.options.svg.optimize) {
						collection.promiseAll(svg => svgTools.SVGO(svg)).then(results => {
							const collection = new svgTools.Collection()
							for (const name in results) {
								collection.add(name, results[name])
							}
							resolve(collection)
						})
					} else {
						resolve(collection)
					}
				})
			} catch(err) {
				reject(err)
			}
		})
	}
	
	toPreprocessortObject(icons) {
		const obj = {};

		icons.forEach((svg, name) => {
			const attrs = getRootAttributes(svg.toString())
			if (attrs.width) delete attrs.width
			if (attrs.height) delete attrs.height
			if (!attrs.viewBox) attrs.viewBox = `0 0 ${svg.width} ${svg.height}`

			obj[name] = `<svg ${toAttributeString(attrs)}>${svg.getBody()}</svg>`
		})
		
		return obj
	}

	/**
	 * Converts all icons into a Sass map string
	 * @returns {Promise<string>}
	 */
	async toScssMap() {
		const obj = this.toPreprocessortObject(await this.icons)
		const arr = []

		for (const name of obj) {
			const value = obj[name]
			arr.push()
		}

		const icons = await this.icons
		const array = [];

		const { variable, indent } = this.options

		icons.forEach((svg, name) => {
			const attrs = getRootAttributes(svg.toString())
			if (attrs.width) delete attrs.width
			if (attrs.height) delete attrs.height
			if (!attrs.viewBox) attrs.viewBox = `0 0 ${svg.width} ${svg.height}`

			array.push(`${indentChar}${name}: '<svg ${toAttributeString(attrs)}>${svg.getBody()}</svg>',`)
		})

		const prefix = '// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n\n'
		const map = ['(', ...array, ')'].join('\n')
		return prefix + '$' + variableName + ': ' + map + ';' + '\n'
	}
	
	async toSassMap() {
		const icons = await this.icons
		const array = [];

		const { variableName, syntax, indentChar } = this.options.sass

		icons.forEach((svg, name) => {
			const attrs = getRootAttributes(svg.toString())
			if (attrs.width) delete attrs.width
			if (attrs.height) delete attrs.height
			if (!attrs.viewBox) attrs.viewBox = `0 0 ${svg.width} ${svg.height}`

			array.push(`${indentChar}${name}: '<svg ${toAttributeString(attrs)}>${svg.getBody()}</svg>',`)
		})

		const prefix = '// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n\n'
		const map = ['(', ...array, ')'].join('\n')
		return prefix + '$' + variableName + ': ' + map + (syntax === 'scss' ? ';' : '') + '\n'
	}

	async toStylusMap() {

	}

	/**
	 * Converts all icons into an SVG sprite string
	 * @returns {Promise<string>}
	 */
	async toSvgSprite() {
		const icons = await this.icons
		const array = []

		icons.forEach((svg, name) => {
			const attrs = getRootAttributes(svg.toString())
			attrs.id = name
			attrs.width = '100%'
			attrs.height = '100%'

			array.push(`\t\t<symbol ${toAttributeString(attrs)}>${svg.getBody()}</symbol>`)
		});

		const defs = `\t<defs>\n${array.join('\n')}\n\t</defs>`
		const svg = `<svg xmlns="http://www.w3.org/2000/svg">\n${defs}\n</svg>`

		if (this.options.svg.optimize && !this.options.svg.pretty) {
			return svg
				.replace(/[\n\r\t]/g, ' ')   // Replace newlines and tabs with space
				.replace(/\s+/g, ' ')        // Replace group spaces with single space
				.replace(/> </g, '><')       // Remove spaces between tags
		}

		return svg
	}

	/**
	 * Writes a Sass file containing a map with all icons to the given filepath
	 * @param   {string} filepath [this.options.sass.output]
	 * @returns {void}
	 */
	async writeSassMap(filepath = this.options.sass.output) {
		if (!filepath || typeof filepath !== 'string') {
			throw new Error('You must pass a path where the file should be written')
		}
		const data = await this.toSassMap()
		fs.writeFile(filepath, data, (err) => {
			if (err) {
				throw new Error(err)
			}
			console.info(`${this.options.sass.syntax === 'scss' ? 'Scss' : 'Sass'} file written to`, filepath)
		})
	}

	/**
	 * Writes a SVG file containing all icons as symbols to the given filepath
	 * @param   {string} filepath [this.options.svg.output]
	 * @returns {void}
	 */
	async writeSvgSprite(filepath = this.options.svg.output) {
		const data = await this.toSvgSprite()
		fs.writeFile(filepath, data, (err) => {
			if (err) {
				throw new Error(err)
			}
			console.info('SVG sprite written to', filepath)
		})
	}

	/**
	 * Generate SVG sprite and/or Sass map from loaded icons
	 * @returns {Promise<string>|void} Returns the Sass map if `options.sass.writeFile = false`
	 */
	async generate() {
		if (this.options.svg) {
			if (this.options.svg.output) {
				this.writeSvgSprite()
			}
		}

		if (this.options.sass) {
			if (this.options.sass.output) {
				this.writeSassMap()
			} else {
				return this.toSassMap()
			}
		}
	}
}

/**
 * Converts an object to an attribute string
 * @param   {object} object
 * @returns {string}
 */
function toAttributeString(object) {
	const attrs = [];
	for (const key in object) {
		const value = object[key]
		if (value) {
			attrs.push(`${key}="${value}"`)
		}
	}
	return attrs.join(' ')
}

/**
 * Returns an object with the root elements attributes
 * @param   {string} string
 * @returns {object}
 */
function getRootAttributes(string) {
	const parsed = HTMLParser.parse(string)
	const attrs = parsed.firstChild.attributes
	delete attrs.xmlns
	return attrs
}

module.exports = GenerateIcons
